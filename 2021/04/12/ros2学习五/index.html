<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>ros2学习五 | Hexo</title>
  <meta name="author" content="John Doe">
  
  <meta name="description" content="ros2学习五ROS2接口扩展目标：了解更多方法来在ROS 2中实现自定义接口
虽然最好来说定义接口是在一个新的package中，比如上一节中的tutorial_interface中，但是有时也会把接口的定义和使用都再一个包里面
如何使用一个已存在的interface在类中使用参数Goal: Cre">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="ros2学习五"/>
  <meta property="og:site_name" content="Hexo"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="shortcut icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Hexo</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/null">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article id="post-ros2学习五" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2021-04-12T01:59:22.000Z"><a href="/2021/04/12/ros2%E5%AD%A6%E4%B9%A0%E4%BA%94/">2021-04-12</a></time>
      
      
  
    <h1 class="p-name title" itemprop="headline name">ros2学习五</h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <h1 id="ros2学习五"><a href="#ros2学习五" class="headerlink" title="ros2学习五"></a>ros2学习五</h1><h1 id="ROS2接口扩展"><a href="#ROS2接口扩展" class="headerlink" title="ROS2接口扩展"></a>ROS2接口扩展</h1><p>目标：了解更多方法来在ROS 2中实现自定义接口</p>
<p>虽然最好来说定义接口是在一个新的package中，比如上一节中的tutorial_interface中，但是有时也会把接口的定义和使用都再一个包里面</p>
<h2 id="如何使用一个已存在的interface"><a href="#如何使用一个已存在的interface" class="headerlink" title="如何使用一个已存在的interface"></a>如何使用一个已存在的interface</h2><h1 id="在类中使用参数"><a href="#在类中使用参数" class="headerlink" title="在类中使用参数"></a>在类中使用参数</h1><p><strong>Goal:</strong> Create and run a class with ROS parameters using Python (rclpy).</p>
<p>在制作自己的节点时，您有时需要添加可以从启动文件设置的参数。</p>
<p>本教程将向您展示如何在Python类中创建这些参数，以及如何将它们设置为在启动文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg create --build-type ament_python python_parameters --dependencies rclpy</span><br></pre></td></tr></table></figure>
<h2 id="更新update-xml以及setup-py"><a href="#更新update-xml以及setup-py" class="headerlink" title="更新update.xml以及setup.py"></a>更新update.xml以及setup.py</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;description&gt;Python parameter tutorial&lt;&#x2F;description&gt;</span><br><span class="line">&lt;maintainer email&#x3D;&quot;you@email.com&quot;&gt;Your Name&lt;&#x2F;maintainer&gt;</span><br><span class="line">&lt;license&gt;Apache License 2.0&lt;&#x2F;license&gt;</span><br></pre></td></tr></table></figure>
<h2 id="python代码"><a href="#python代码" class="headerlink" title="python代码"></a>python代码</h2><p>再<code>dev_ws/src/python_parameters/python_parameters</code> 目录下，新建<code>python_parameters_node.py</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import rclpy</span><br><span class="line">import rclpy.node</span><br><span class="line">from rclpy.exceptions import ParameterNotDeclaredException</span><br><span class="line">from rcl_interfaces.msg import ParameterType</span><br><span class="line"></span><br><span class="line">class MinimalParam(rclpy.node.Node):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__(&#39;minimal_param_node&#39;)</span><br><span class="line">        timer_period &#x3D; 2  # seconds</span><br><span class="line">        self.timer &#x3D; self.create_timer(timer_period, self.timer_callback)</span><br><span class="line"></span><br><span class="line">        self.declare_parameter(&#39;my_parameter&#39;, &#39;world&#39;)</span><br><span class="line"></span><br><span class="line">    def timer_callback(self):</span><br><span class="line">        my_param &#x3D; self.get_parameter(&#39;my_parameter&#39;).get_parameter_value().string_value</span><br><span class="line"></span><br><span class="line">        self.get_logger().info(&#39;Hello %s!&#39; % my_param)</span><br><span class="line"></span><br><span class="line">        my_new_param &#x3D; rclpy.parameter.Parameter(</span><br><span class="line">            &#39;my_parameter&#39;,</span><br><span class="line">            rclpy.Parameter.Type.STRING,</span><br><span class="line">            &#39;world&#39;</span><br><span class="line">        )</span><br><span class="line">        all_new_parameters &#x3D; [my_new_param]</span><br><span class="line">        self.set_parameters(all_new_parameters)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    rclpy.init()</span><br><span class="line">    node &#x3D; MinimalParam()</span><br><span class="line">    rclpy.spin(node)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="代码审查"><a href="#代码审查" class="headerlink" title="代码审查"></a>代码审查</h3><p>注意：在获取或设置之前必须声明参数，或者将提出<code>parameternotdeclaredException</code>异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import rclpy</span><br><span class="line">import rclpy.node</span><br><span class="line">from rclpy.exceptions import ParameterNotDeclaredException</span><br><span class="line">from rcl_interfaces.msg import ParameterType</span><br></pre></td></tr></table></figure>
<p>下一段代码创建类和构造函数。timer被初始化(timer_period设置为2秒)，这将导致timer_callback函数每两秒执行一次。构造函数的self.declare_parameter(‘my_parameter’， ‘world’)一行创建了一个名为my_parameter的形参，默认值为world。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MinimalParam(rclpy.node.Node):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__(&#39;minimal_param_node&#39;)</span><br><span class="line">        timer_period &#x3D; 2  # seconds</span><br><span class="line">        self.timer &#x3D; self.create_timer(timer_period, self.timer_callback)</span><br><span class="line"></span><br><span class="line">        self.declare_parameter(&#39;my_parameter&#39;, &#39;world&#39;)</span><br></pre></td></tr></table></figure>
<p>timer_callback函数的第一行从节点获取参数my_parameter，并将其存储在my_param中。接下来，get_logger函数确保打印了消息。然后，我们将参数’ my_parameter ‘设置回默认的字符串值’ world ‘。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def timer_callback(self):</span><br><span class="line">    my_param &#x3D; self.get_parameter(&#39;my_parameter&#39;).get_parameter_value().string_value</span><br><span class="line"></span><br><span class="line">    self.get_logger().info(&#39;Hello %s!&#39; % my_param)</span><br><span class="line"></span><br><span class="line">    my_new_param &#x3D; rclpy.parameter.Parameter(</span><br><span class="line">        &#39;my_parameter&#39;,</span><br><span class="line">        rclpy.Parameter.Type.STRING,</span><br><span class="line">        &#39;world&#39;</span><br><span class="line">    )</span><br><span class="line">    all_new_parameters &#x3D; [my_new_param]</span><br><span class="line">    self.set_parameters(all_new_parameters)</span><br></pre></td></tr></table></figure>
<p>timer_callback之后是初始化ROS 2的主函数。然后定义名为node的MinimalParam类的实例。最后，rclpy.spin开始处理来自节点的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def main():</span><br><span class="line">    rclpy.init()</span><br><span class="line">    node &#x3D; MinimalParam()</span><br><span class="line">    rclpy.spin(node)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="添加对参数的描述parameterDescriptor"><a href="#添加对参数的描述parameterDescriptor" class="headerlink" title="添加对参数的描述parameterDescriptor."></a>添加对参数的描述parameterDescriptor.</h3><p>还可以为参数设置描述符。描述符允许您指定参数的类型和一些描述文本。为了让它工作，<code>__init__</code>代码必须更改为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class MinimalParam(rclpy.node.Node):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__(&#39;minimal_param_node&#39;)</span><br><span class="line">        timer_period &#x3D; 2  # seconds</span><br><span class="line">        self.timer &#x3D; self.create_timer(timer_period, self.timer_callback)</span><br><span class="line"></span><br><span class="line">        from rcl_interfaces.msg import ParameterDescriptor</span><br><span class="line">        my_parameter_descriptor &#x3D; ParameterDescriptor(type&#x3D;ParameterType.PARAMETER_STRING,</span><br><span class="line">                                                      description&#x3D;&#39;This parameter is mine!&#39;)</span><br><span class="line"></span><br><span class="line">        self.declare_parameter(&#39;my_parameter&#39;,</span><br><span class="line">                               &#39;default value for my_parameter&#39;,</span><br><span class="line">                               my_parameter_descriptor)</span><br></pre></td></tr></table></figure>
<p>其余的代码保持不变。运行节点之后，可以运行<code>ros2 param description /minimal_param_node my_parameter</code>查看类型和描述。</p>
<h2 id="Add-an-entry-point"><a href="#Add-an-entry-point" class="headerlink" title="Add an entry point"></a>Add an entry point</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">entry_points&#x3D;&#123;</span><br><span class="line">    &#39;console_scripts&#39;: [</span><br><span class="line">        &#39;param_talker &#x3D; python_parameters.python_parameters_node:main&#39;,</span><br><span class="line">    ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="build-and-run"><a href="#build-and-run" class="headerlink" title="build and run"></a>build and run</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rosdep install -i --from-path src --rosdistro dashing -y</span><br><span class="line">cd ~&#x2F;dev_ws</span><br><span class="line">colcon build</span><br></pre></td></tr></table></figure>
<p>新打开一个终端，两个source之后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 run python_parameters param_talker</span><br></pre></td></tr></table></figure>
<p>会出现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[INFO] [minimal_param_node]: Hello world!</span><br><span class="line">[INFO] [minimal_param_node]: Hello world1!</span><br><span class="line">[INFO] [minimal_param_node]: Hello world1!</span><br><span class="line">[INFO] [minimal_param_node]: Hello world1!</span><br></pre></td></tr></table></figure>
<p>两种方式去改变这个参数</p>
<h3 id="通过命令行"><a href="#通过命令行" class="headerlink" title="通过命令行"></a>通过命令行</h3><p>我们可以通过命令行还修改参数的设置</p>
<p>首先查看现在有什么参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ros2 param list</span><br><span class="line">&#x2F;minimal_param_node:</span><br><span class="line">  my_parameter</span><br><span class="line">  use_sim_time</span><br></pre></td></tr></table></figure>
<p>接下来使用命令行还修改参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 param set &#x2F;minimal_param_node my_parameter earth</span><br></pre></td></tr></table></figure>
<p>现在去查看另外一个终端 就会出现hello earth</p>
<h3 id="通过launch文件"><a href="#通过launch文件" class="headerlink" title="通过launch文件"></a>通过launch文件</h3><p>您还可以在启动文件中设置参数，但首先需要添加一个启动目录。在dev_ws/src/python_parameters/目录中，创建一个名为launch的新目录。在这里，创建一个名为python_parameters_launch.py的新文件</p>
<p><code>emulate_tty</code>, which prints output to the console, is not available in Dashing.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from launch import LaunchDescription</span><br><span class="line">from launch_ros.actions import Node</span><br><span class="line"></span><br><span class="line">def generate_launch_description():</span><br><span class="line">    return LaunchDescription([</span><br><span class="line">        Node(</span><br><span class="line">            package&#x3D;&#39;python_parameters&#39;,</span><br><span class="line">            node_executable&#x3D;&#39;param_talker&#39;,</span><br><span class="line">            node_name&#x3D;&#39;custom_parameter_node&#39;,</span><br><span class="line">            output&#x3D;&#39;screen&#39;,</span><br><span class="line">            parameters&#x3D;[</span><br><span class="line">                &#123;&#39;my_parameter&#39;: &#39;earth&#39;&#125;</span><br><span class="line">            ]</span><br><span class="line">        )</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure>
<p>在这里，您可以看到我们在启动Node Parameter_Node时将My_Parameter设置为earth。</p>
<p>现在打开setup.py文件。将导入语句添加到文件的顶部，并将另一条新语句添加到data_files参数中，以包含所有启动文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 launch python_parameters python_parameters_launch.py</span><br></pre></td></tr></table></figure>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>您创建了一个带有自定义参数的节点，该参数可以从启动文件或命令行设置。您编写了一个参数对话器的代码:一个Python节点声明，然后循环获取和设置一个字符串参数。您添加了入口点，以便可以构建和运行它，并使用ros2 param与参数对话器交互。</p>
<h1 id="creating-an-action"><a href="#creating-an-action" class="headerlink" title="creating an action"></a>creating an action</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd dev_ws&#x2F;src</span><br><span class="line">ros2 pkg create action_tutorials_interfaces</span><br></pre></td></tr></table></figure>
<h2 id="定义一个action"><a href="#定义一个action" class="headerlink" title="定义一个action"></a>定义一个action</h2><p>action在.action文件中定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Request</span><br><span class="line">---</span><br><span class="line"># Result</span><br><span class="line">---</span><br><span class="line"># Feedback</span><br></pre></td></tr></table></figure>
<p>操作定义由三个用—-分隔的消息定义组成。</p>
<ul>
<li>Request消息从操作客户端发送到启动新goal的操作服务器。</li>
<li>Result 从action服务端出到action客户端，当goal已经完成。</li>
<li>feedback 从动作服务器周期性地发送到具有关于目标的更新的动作客户端。</li>
</ul>
<p>action的一个实例通常被称为goal。</p>
<p>假设我们想定义一个新的动作“Fibonacci”来计算Fibonacci序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd action_tutorials_interfaces</span><br><span class="line">mkdir action</span><br><span class="line">vi Fibonacci.action</span><br><span class="line">int32 order</span><br><span class="line">---</span><br><span class="line">int32[] sequence</span><br><span class="line">---</span><br><span class="line">int32[] partial_sequence</span><br></pre></td></tr></table></figure>
<p>目标请求是我们想要计算的斐波纳契序列的order，结果是最终sequence，反馈是到目前为止计算的Partial_sequence。</p>
<h2 id="building-an-action"><a href="#building-an-action" class="headerlink" title="building an action"></a>building an action</h2><p>在代码中使用新的Fibonacci动作类型之前，必须将定义传递给rosidl code generation pipeline.</p>
<p>这是通过在action_tutorials_interfaces的ament_package()行之前添加以下几行CMakeLists.txt来完成的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find_package(rosidl_default_generators REQUIRED)</span><br><span class="line"></span><br><span class="line">rosidl_generate_interfaces($&#123;PROJECT_NAME&#125;</span><br><span class="line">  &quot;action&#x2F;Fibonacci.action&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>我们还应该将所需的依赖项添加到package.xml中:</p>
<p>注意，我们需要依赖于action_msgs，因为action操作定义包括其他元数据（例如目标ID）。</p>
<p>打开<code>package.xml</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;buildtool_depend&gt;rosidl_default_generators&lt;&#x2F;buildtool_depend&gt;</span><br><span class="line"></span><br><span class="line">&lt;depend&gt;action_msgs&lt;&#x2F;depend&gt;</span><br><span class="line"></span><br><span class="line">&lt;member_of_group&gt;rosidl_interface_packages&lt;&#x2F;member_of_group&gt;</span><br></pre></td></tr></table></figure>
<p>然后进行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 action show action_tutorials_interfaces&#x2F;action&#x2F;Fibonacci</span><br></pre></td></tr></table></figure>
<h1 id="写一个action的客户端和服务端"><a href="#写一个action的客户端和服务端" class="headerlink" title="写一个action的客户端和服务端"></a>写一个action的客户端和服务端</h1><p>action是ROS 2中异步通信的一种形式。action客户端向action服务器发送goal请求。action服务器向action客户端发送目标feedback和result。</p>
<h2 id="写一个action的服务端"><a href="#写一个action的服务端" class="headerlink" title="写一个action的服务端"></a>写一个action的服务端</h2><p>下面写一个服务端用之前定义好的action。为了教程的简单，我们会把服务端单独做成一个文件</p>
<p>打开home目录，建立文件<code>fibonacci_action_server.py</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import rclpy</span><br><span class="line">from rclpy.action import ActionServer</span><br><span class="line">from rclpy.node import Node</span><br><span class="line"></span><br><span class="line">from action_tutorials_interfaces.action import Fibonacci</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class FibonacciActionServer(Node):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__(&#39;fibonacci_action_server&#39;)</span><br><span class="line">        self._action_server &#x3D; ActionServer(</span><br><span class="line">            self,</span><br><span class="line">            Fibonacci,</span><br><span class="line">            &#39;fibonacci&#39;,</span><br><span class="line">            self.execute_callback)</span><br><span class="line"></span><br><span class="line">    def execute_callback(self, goal_handle):</span><br><span class="line">        self.get_logger().info(&#39;Executing goal...&#39;)</span><br><span class="line">        result &#x3D; Fibonacci.Result()</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main(args&#x3D;None):</span><br><span class="line">    rclpy.init(args&#x3D;args)</span><br><span class="line"></span><br><span class="line">    fibonacci_action_server &#x3D; FibonacciActionServer()</span><br><span class="line"></span><br><span class="line">    rclpy.spin(fibonacci_action_server)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>第8行定义了一个类FibonacciActionServer，它是Node的子类。通过调用节点的构造函数来初始化该类，将我们的节点命名为fibonacci_action_server:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super().__init__(&#39;fibonacci_action_server&#39;)</span><br></pre></td></tr></table></figure>
<p>在构造函数中，我们还实例化了一个新的action server:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self._action_server &#x3D; ActionServer(</span><br><span class="line">    self,</span><br><span class="line">    Fibonacci,</span><br><span class="line">    &#39;fibonacci&#39;,</span><br><span class="line">    self.execute_callback)</span><br></pre></td></tr></table></figure>
<p>action server需要四个参数:</p>
<ol>
<li>ROS 2节点将动作客户端添加到：self。</li>
<li>动作的类型：Fibonacci（以第5行导入）。action_tutorials_interfaces</li>
<li>动作名称：’fibonacci’。</li>
<li>用于执行接受的目标的回调函数：self.execute_callback。此回调必须返回操作类型的结果消息。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def execute_callback(self, goal_handle):</span><br><span class="line">    self.get_logger().info(&#39;Executing goal...&#39;)action_tutorials_interfaces</span><br><span class="line">    result &#x3D; Fibonacci.Result()</span><br><span class="line">    return result</span><br><span class="line">python3 fibonacci_action_server.py</span><br></pre></td></tr></table></figure>
<p>在另一个终端中，我们可以使用命令行界面来发送目标：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 action send_goal fibonacci action_tutorials_interfaces&#x2F;action&#x2F;Fibonacci &quot;&#123;order: 5&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>将看见</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Waiting for an action server to become available...</span><br><span class="line">Sending goal:</span><br><span class="line">     order: 5</span><br><span class="line"></span><br><span class="line">Goal accepted with ID: 0a7d8ac416a14368b467604786edb81a</span><br><span class="line"></span><br><span class="line">Result:</span><br><span class="line">    sequence: []</span><br><span class="line"></span><br><span class="line">Goal finished with status: ABORTED</span><br></pre></td></tr></table></figure>
<p>再服务端，我们有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[INFO] [fibonacci_action_server]: Executing goal...</span><br><span class="line">[WARN] [fibonacci_action_server]: Goal state not set, assuming aborted. Goal ID: [ 10 125 138 196  22 161  67 104 180 103  96  71 134 237 184  26]</span><br></pre></td></tr></table></figure>
<p>在运行操作服务器的终端中，您应该看到一条日志消息“Executing goal…”，后面是一个目标状态未设置的警告。默认情况下，如果在执行回调中没有设置目标句柄状态，它将假定为aborted状态。</p>
<p>我们可以使用目标句柄上的succeed()方法来指示目标成功:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def execute_callback(self, goal_handle):</span><br><span class="line">    self.get_logger().info(&#39;Executing goal...&#39;)</span><br><span class="line">    goal_handle.succeed()</span><br><span class="line">    result &#x3D; Fibonacci.Result()</span><br><span class="line">    return result</span><br></pre></td></tr></table></figure>
<p>现在，如果重新启动操作服务器并发送另一个goal，您应该会看到goal已经完成，状态为SUCCEEDED。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Waiting for an action server to become available...</span><br><span class="line">Sending goal:</span><br><span class="line">     order: 5</span><br><span class="line"></span><br><span class="line">Goal accepted with ID: 7ca482d0b76546cdbaaa4bf03647d8fa</span><br><span class="line"></span><br><span class="line">Result:</span><br><span class="line">    sequence: []</span><br><span class="line"></span><br><span class="line">Goal finished with status: SUCCEEDED</span><br></pre></td></tr></table></figure>
<p>现在，让我们的目标执行实际计算并返回所请求的斐波那契序列:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def execute_callback(self, goal_handle):</span><br><span class="line">    self.get_logger().info(&#39;Executing goal...&#39;)</span><br><span class="line"></span><br><span class="line">    sequence &#x3D; [0, 1]</span><br><span class="line"></span><br><span class="line">    for i in range(1, goal_handle.request.order):</span><br><span class="line">        sequence.append(sequence[i] + sequence[i-1])</span><br><span class="line"></span><br><span class="line">    goal_handle.succeed()</span><br><span class="line"></span><br><span class="line">    result &#x3D; Fibonacci.Result()</span><br><span class="line">    result.sequence &#x3D; sequence</span><br><span class="line">    return result</span><br></pre></td></tr></table></figure>
<p>在计算序列之后，我们在返回之前将其分配给result消息字段。</p>
<p>.再次重启操作服务器并发送另一个目标。您应该看到目标以正确的结果序列结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Waiting for an action server to become available...</span><br><span class="line">Sending goal:</span><br><span class="line">     order: 5</span><br><span class="line"></span><br><span class="line">Goal accepted with ID: 06a9917c3e664f6d8e39f51bc5f31802</span><br><span class="line"></span><br><span class="line">Result:</span><br><span class="line">    sequence: [0, 1, 1, 2, 3, 5]</span><br><span class="line"></span><br><span class="line">Goal finished with status: SUCCEEDED</span><br></pre></td></tr></table></figure>
<h3 id="Publishing-feedback"><a href="#Publishing-feedback" class="headerlink" title="Publishing feedback"></a>Publishing feedback</h3><p>关于action的一个很好的事情是在目标执行期间提供对动作客户端的反馈的能力。我们可以通过调用目标句柄的publish_feedback（）方法使我们的action服务器发布action客户端的反馈。</p>
<p>我们将替换sequence变量，并使用feedback消息来存储序列。在for循环中每次更新反馈信息后，我们都会发布feedback信息并休眠以获得戏剧性效果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">import rclpy</span><br><span class="line">from rclpy.action import ActionServer</span><br><span class="line">from rclpy.node import Node</span><br><span class="line"></span><br><span class="line">from action_tutorials_interfaces.action import Fibonacci</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class FibonacciActionServer(Node):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__(&#39;fibonacci_action_server&#39;)</span><br><span class="line">        self._action_server &#x3D; ActionServer(</span><br><span class="line">            self,</span><br><span class="line">            Fibonacci,</span><br><span class="line">            &#39;fibonacci&#39;,</span><br><span class="line">            self.execute_callback)</span><br><span class="line"></span><br><span class="line">    def execute_callback(self, goal_handle):</span><br><span class="line">        self.get_logger().info(&#39;Executing goal...&#39;)</span><br><span class="line"></span><br><span class="line">        feedback_msg &#x3D; Fibonacci.Feedback()</span><br><span class="line">        feedback_msg.partial_sequence &#x3D; [0, 1]</span><br><span class="line"></span><br><span class="line">        for i in range(1, goal_handle.request.order):</span><br><span class="line">            feedback_msg.partial_sequence.append(</span><br><span class="line">                feedback_msg.partial_sequence[i] + feedback_msg.partial_sequence[i-1])</span><br><span class="line">            self.get_logger().info(&#39;Feedback: &#123;0&#125;&#39;.format(feedback_msg.partial_sequence))</span><br><span class="line">            goal_handle.publish_feedback(feedback_msg)</span><br><span class="line">            time.sleep(1)</span><br><span class="line"></span><br><span class="line">        goal_handle.succeed()</span><br><span class="line"></span><br><span class="line">        result &#x3D; Fibonacci.Result()</span><br><span class="line">        result.sequence &#x3D; feedback_msg.partial_sequence</span><br><span class="line">        return result</span><br></pre></td></tr></table></figure>
<p>在重新启动action服务器后，我们可以通过使用命令行工具和—feedback选项确认反馈现在已经发布了:</p>
<h2 id="写一个action客户端"><a href="#写一个action客户端" class="headerlink" title="写一个action客户端"></a>写一个action客户端</h2><p>也是单个文件,<code>fibonacci_action_client.py</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import rclpy</span><br><span class="line">from rclpy.action import ActionClient</span><br><span class="line">from rclpy.node import Node</span><br><span class="line"></span><br><span class="line">from action_tutorials_interfaces.action import Fibonacci</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class FibonacciActionClient(Node):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__(&#39;fibonacci_action_client&#39;)</span><br><span class="line">        self._action_client &#x3D; ActionClient(self, Fibonacci, &#39;fibonacci&#39;)</span><br><span class="line"></span><br><span class="line">    def send_goal(self, order):</span><br><span class="line">        goal_msg &#x3D; Fibonacci.Goal()</span><br><span class="line">        goal_msg.order &#x3D; order</span><br><span class="line"></span><br><span class="line">        self._action_client.wait_for_server()</span><br><span class="line"></span><br><span class="line">        return self._action_client.send_goal_async(goal_msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main(args&#x3D;None):</span><br><span class="line">    rclpy.init(args&#x3D;args)</span><br><span class="line"></span><br><span class="line">    action_client &#x3D; FibonacciActionClient()</span><br><span class="line"></span><br><span class="line">    future &#x3D; action_client.send_goal(10)</span><br><span class="line"></span><br><span class="line">    rclpy.spin_until_future_complete(action_client, future)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>我们还在FibonAcciaInctionClient类中定义了一个方法send_goal：此方法等待可用的action服务器，然后向服务器发送目标。它返回一个future，这个future是我们未来可以获取结果的一个对象</p>
<h3 id="获得结果"><a href="#获得结果" class="headerlink" title="获得结果"></a>获得结果</h3><p>我们可以发送一个目标，但是我们如何知道它何时完成呢?我们可以通过几个步骤得到结果信息。首先，我们需要为发送的目标获取一个目标句柄。然后，我们可以使用目标句柄来请求结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import rclpy</span><br><span class="line">from rclpy.action import ActionClient</span><br><span class="line">from rclpy.node import Node</span><br><span class="line"></span><br><span class="line">from action_tutorials_interfaces.action import Fibonacci</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class FibonacciActionClient(Node):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__(&#39;fibonacci_action_client&#39;)</span><br><span class="line">        self._action_client &#x3D; ActionClient(self, Fibonacci, &#39;fibonacci&#39;)</span><br><span class="line"></span><br><span class="line">    def send_goal(self, order):</span><br><span class="line">        goal_msg &#x3D; Fibonacci.Goal()</span><br><span class="line">        goal_msg.order &#x3D; order</span><br><span class="line"></span><br><span class="line">        self._action_client.wait_for_server()</span><br><span class="line"></span><br><span class="line">        self._send_goal_future &#x3D; self._action_client.send_goal_async(goal_msg)</span><br><span class="line"></span><br><span class="line">        self._send_goal_future.add_done_callback(self.goal_response_callback)</span><br><span class="line"></span><br><span class="line">    def goal_response_callback(self, future):</span><br><span class="line">        goal_handle &#x3D; future.result()</span><br><span class="line">        if not goal_handle.accepted:</span><br><span class="line">            self.get_logger().info(&#39;Goal rejected :(&#39;)</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        self.get_logger().info(&#39;Goal accepted :)&#39;)</span><br><span class="line"></span><br><span class="line">        self._get_result_future &#x3D; goal_handle.get_result_async()</span><br><span class="line">        self._get_result_future.add_done_callback(self.get_result_callback)</span><br><span class="line"></span><br><span class="line">    def get_result_callback(self, future):</span><br><span class="line">        result &#x3D; future.result().result</span><br><span class="line">        self.get_logger().info(&#39;Result: &#123;0&#125;&#39;.format(result.sequence))</span><br><span class="line">        rclpy.shutdown()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main(args&#x3D;None):</span><br><span class="line">    rclpy.init(args&#x3D;args)</span><br><span class="line"></span><br><span class="line">    action_client &#x3D; FibonacciActionClient()</span><br><span class="line"></span><br><span class="line">    action_client.send_goal(10)</span><br><span class="line"></span><br><span class="line">    rclpy.spin(action_client)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>ActionClient.send_goal_async()方法为目标句柄返回一个future。首先，当future完成时注册一个回调函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self._send_goal_future.add_done_callback(self.goal_response_callback)</span><br></pre></td></tr></table></figure>
<p>注意，当操作服务器接受或拒绝goal请求时，future就完成了。让我们更详细地看看goal_response_callback。</p>
<p>我们可以检查目标是否被拒绝，并提前返回，因为我们知道不会有结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def goal_response_callback(self, future):</span><br><span class="line">    goal_handle &#x3D; future.result()</span><br><span class="line">    if not goal_handle.accepted:</span><br><span class="line">        self.get_logger().info(&#39;Goal rejected :(&#39;)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    self.get_logger().info(&#39;Goal accepted :)&#39;)</span><br></pre></td></tr></table></figure>
<p>现在我们已经有了一个目标句柄，我们可以使用它来通过get_result_async()方法请求结果。</p>
<p>与发送目标类似，我们将得到一个future，当结果准备好时，它将完成。让我们注册一个回调，就像我们为目标响应所做的那样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self._get_result_future &#x3D; goal_handle.get_result_async()</span><br><span class="line">self._get_result_future.add_done_callback(self.get_result_callback)</span><br></pre></td></tr></table></figure>
<p>在回调中，我们记录了结果序列并关闭了ROS 2以获得干净的退出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def get_result_callback(self, future):</span><br><span class="line">    result &#x3D; future.result().result</span><br><span class="line">    self.get_logger().info(&#39;Result: &#123;0&#125;&#39;.format(result.sequence))</span><br><span class="line">    rclpy.shutdown()</span><br></pre></td></tr></table></figure>
<p>再一次尝试运行服务端和客户端的代码</p>
<p>客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[INFO] [fibonacci_action_client]: Goal accepted :)</span><br><span class="line">[INFO] [fibonacci_action_client]: Result: array(&#39;i&#39;, [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55])</span><br></pre></td></tr></table></figure>
<p>服务端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[INFO] [fibonacci_action_server]: Executing goal...</span><br><span class="line">[INFO] [fibonacci_action_server]: Feedback: array(&#39;i&#39;, [0, 1, 1])</span><br><span class="line">[INFO] [fibonacci_action_server]: Feedback: array(&#39;i&#39;, [0, 1, 1, 2])</span><br><span class="line">[INFO] [fibonacci_action_server]: Feedback: array(&#39;i&#39;, [0, 1, 1, 2, 3])</span><br><span class="line">[INFO] [fibonacci_action_server]: Feedback: array(&#39;i&#39;, [0, 1, 1, 2, 3, 5])</span><br><span class="line">[INFO] [fibonacci_action_server]: Feedback: array(&#39;i&#39;, [0, 1, 1, 2, 3, 5, 8])</span><br><span class="line">[INFO] [fibonacci_action_server]: Feedback: array(&#39;i&#39;, [0, 1, 1, 2, 3, 5, 8, 13])</span><br><span class="line">[INFO] [fibonacci_action_server]: Feedback: array(&#39;i&#39;, [0, 1, 1, 2, 3, 5, 8, 13, 21])</span><br><span class="line">[INFO] [fibonacci_action_server]: Feedback: array(&#39;i&#39;, [0, 1, 1, 2, 3, 5, 8, 13, 21, 34])</span><br><span class="line">[INFO] [fibonacci_action_server]: Feedback: array(&#39;i&#39;, [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55])</span><br></pre></td></tr></table></figure>
<h3 id="获得feedback"><a href="#获得feedback" class="headerlink" title="获得feedback"></a>获得feedback</h3><p>我们的action客户端可以发送目标。nice！但如果我们可以获得关于我们从Action Server发送的目标的一些反馈，那就太好了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import rclpy</span><br><span class="line">from rclpy.action import ActionClient</span><br><span class="line">from rclpy.node import Node</span><br><span class="line"></span><br><span class="line">from action_tutorials_interfaces.action import Fibonacci</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class FibonacciActionClient(Node):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__(&#39;fibonacci_action_client&#39;)</span><br><span class="line">        self._action_client &#x3D; ActionClient(self, Fibonacci, &#39;fibonacci&#39;)</span><br><span class="line"></span><br><span class="line">    def send_goal(self, order):</span><br><span class="line">        goal_msg &#x3D; Fibonacci.Goal()</span><br><span class="line">        goal_msg.order &#x3D; order</span><br><span class="line"></span><br><span class="line">        self._action_client.wait_for_server()</span><br><span class="line"></span><br><span class="line">        self._send_goal_future &#x3D; self._action_client.send_goal_async(goal_msg, feedback_callback&#x3D;self.feedback_callback)</span><br><span class="line"></span><br><span class="line">        self._send_goal_future.add_done_callback(self.goal_response_callback)</span><br><span class="line"></span><br><span class="line">    def goal_response_callback(self, future):</span><br><span class="line">        goal_handle &#x3D; future.result()</span><br><span class="line">        if not goal_handle.accepted:</span><br><span class="line">            self.get_logger().info(&#39;Goal rejected :(&#39;)</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        self.get_logger().info(&#39;Goal accepted :)&#39;)</span><br><span class="line"></span><br><span class="line">        self._get_result_future &#x3D; goal_handle.get_result_async()</span><br><span class="line">        self._get_result_future.add_done_callback(self.get_result_callback)</span><br><span class="line"></span><br><span class="line">    def get_result_callback(self, future):</span><br><span class="line">        result &#x3D; future.result().result</span><br><span class="line">        self.get_logger().info(&#39;Result: &#123;0&#125;&#39;.format(result.sequence))</span><br><span class="line">        rclpy.shutdown()</span><br><span class="line"></span><br><span class="line">    def feedback_callback(self, feedback_msg):</span><br><span class="line">        feedback &#x3D; feedback_msg.feedback</span><br><span class="line">        self.get_logger().info(&#39;Received feedback: &#123;0&#125;&#39;.format(feedback.partial_sequence))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main(args&#x3D;None):</span><br><span class="line">    rclpy.init(args&#x3D;args)</span><br><span class="line"></span><br><span class="line">    action_client &#x3D; FibonacciActionClient()</span><br><span class="line"></span><br><span class="line">    action_client.send_goal(10)</span><br><span class="line"></span><br><span class="line">    rclpy.spin(action_client)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>以下是反馈信息的回调函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def feedback_callback(self, feedback_msg):</span><br><span class="line">       feedback &#x3D; feedback_msg.feedback</span><br><span class="line">       self.get_logger().info(&#39;Received feedback: &#123;0&#125;&#39;.format(feedback.partial_sequence))</span><br></pre></td></tr></table></figure>
<p>在回调中，我们获得消息的反馈部分，并将partial_sequence字段打印到屏幕上。</p>
<p>我们需要使用Action Client注册回调。当我们发送目标时，这将通过此外将回调传递给行动客户端来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self._send_goal_future &#x3D; self._action_client.send_goal_async(goal_msg, feedback_callback&#x3D;self.feedback_callback)</span><br></pre></td></tr></table></figure>
<p>运行客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[INFO] [fibonacci_action_client]: Goal accepted :)</span><br><span class="line">[INFO] [fibonacci_action_client]: Received feedback: array(&#39;i&#39;, [0, 1, 1])</span><br><span class="line">[INFO] [fibonacci_action_client]: Received feedback: array(&#39;i&#39;, [0, 1, 1, 2])</span><br><span class="line">[INFO] [fibonacci_action_client]: Received feedback: array(&#39;i&#39;, [0, 1, 1, 2, 3])</span><br><span class="line">[INFO] [fibonacci_action_client]: Received feedback: array(&#39;i&#39;, [0, 1, 1, 2, 3, 5])</span><br><span class="line">[INFO] [fibonacci_action_client]: Received feedback: array(&#39;i&#39;, [0, 1, 1, 2, 3, 5, 8])</span><br><span class="line">[INFO] [fibonacci_action_client]: Received feedback: array(&#39;i&#39;, [0, 1, 1, 2, 3, 5, 8, 13])</span><br><span class="line">[INFO] [fibonacci_action_client]: Received feedback: array(&#39;i&#39;, [0, 1, 1, 2, 3, 5, 8, 13, 21])</span><br><span class="line">[INFO] [fibonacci_action_client]: Received feedback: array(&#39;i&#39;, [0, 1, 1, 2, 3, 5, 8, 13, 21, 34])</span><br><span class="line">[INFO] [fibonacci_action_client]: Received feedback: array(&#39;i&#39;, [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55])</span><br><span class="line">[INFO] [fibonacci_action_client]: Result: array(&#39;i&#39;, [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55])</span><br></pre></td></tr></table></figure>
<p>服务端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[INFO] [fibonacci_action_server]: Executing goal...</span><br><span class="line">[INFO] [fibonacci_action_server]: Feedback: array(&#39;i&#39;, [0, 1, 1])</span><br><span class="line">[INFO] [fibonacci_action_server]: Feedback: array(&#39;i&#39;, [0, 1, 1, 2])</span><br><span class="line">[INFO] [fibonacci_action_server]: Feedback: array(&#39;i&#39;, [0, 1, 1, 2, 3])</span><br><span class="line">[INFO] [fibonacci_action_server]: Feedback: array(&#39;i&#39;, [0, 1, 1, 2, 3, 5])</span><br><span class="line">[INFO] [fibonacci_action_server]: Feedback: array(&#39;i&#39;, [0, 1, 1, 2, 3, 5, 8])</span><br><span class="line">[INFO] [fibonacci_action_server]: Feedback: array(&#39;i&#39;, [0, 1, 1, 2, 3, 5, 8, 13])</span><br><span class="line">[INFO] [fibonacci_action_server]: Feedback: array(&#39;i&#39;, [0, 1, 1, 2, 3, 5, 8, 13, 21])</span><br><span class="line">[INFO] [fibonacci_action_server]: Feedback: array(&#39;i&#39;, [0, 1, 1, 2, 3, 5, 8, 13, 21, 34])</span><br><span class="line">[INFO] [fibonacci_action_server]: Feedback: array(&#39;i&#39;, [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55])</span><br></pre></td></tr></table></figure>
<h1 id="使用Launch启动-监视多个节点"><a href="#使用Launch启动-监视多个节点" class="headerlink" title="使用Launch启动/监视多个节点"></a>使用Launch启动/监视多个节点</h1><h2 id="ros2-启动系统"><a href="#ros2-启动系统" class="headerlink" title="ros2 启动系统"></a>ros2 启动系统</h2><p>ROS 2中的启动系统负责帮助用户描述他们的系统配置，然后按照描述执行。系统的配置包括运行什么程序，在哪里运行它们，传递什么参数，以及ROS特定的约定，这些约定通过为组件提供不同的配置，使组件在整个系统中易于重用，它还负责监视已启动流程的状态，并报告和/或对这些流程状态的变化作出反应。</p>
<p>用Python编写的启动文件可以启动和停止不同的节点，也可以触发和处理各种事件。提供这个框架的包是launch_ros，它使用底层的非特定于ros的启动框架。</p>
<h2 id="写一个启动文件"><a href="#写一个启动文件" class="headerlink" title="写一个启动文件"></a>写一个启动文件</h2><p>当我们进行了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 pkg create --build-type &#x3D; ament_python my_package --dependency [deps]</span><br></pre></td></tr></table></figure>
<p>应该就会有如下文件结构, 再建一个了launch文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">src&#x2F;</span><br><span class="line">    my_package&#x2F;</span><br><span class="line">        launch&#x2F;</span><br><span class="line">        setup.py</span><br><span class="line">        setup.cfg</span><br><span class="line">        package.xml</span><br></pre></td></tr></table></figure>
<p>为了让colcon找到启动文件，我们需要使用setup的data_files参数通知Python的安装工具我们的启动文件。</p>
<p>在setup.py里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">from glob import glob</span><br><span class="line">from setuptools import setup</span><br><span class="line"></span><br><span class="line">package_name &#x3D; &#39;my_package&#39;</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    # Other parameters ...</span><br><span class="line">    data_files&#x3D;[</span><br><span class="line">        # ... Other data files</span><br><span class="line">        # Include all launch files. This is the most important line here!</span><br><span class="line">        (os.path.join(&#39;share&#39;, package_name), glob(&#39;launch&#x2F;*.launch.py&#39;))</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="写一个launch文件"><a href="#写一个launch文件" class="headerlink" title="写一个launch文件"></a>写一个launch文件</h2><p>在启动目录中，使用.launch.py后缀创建一个新的启动文件。例如my_script.launch.py。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import launch</span><br><span class="line">import launch.actions</span><br><span class="line">import launch.substitutions</span><br><span class="line">import launch_ros.actions</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def generate_launch_description():</span><br><span class="line">    return launch.LaunchDescription([</span><br><span class="line">        launch.actions.DeclareLaunchArgument(</span><br><span class="line">            &#39;node_prefix&#39;,</span><br><span class="line">            default_value&#x3D;[launch.substitutions.EnvironmentVariable(&#39;USER&#39;), &#39;_&#39;],</span><br><span class="line">            description&#x3D;&#39;Prefix for node names&#39;),</span><br><span class="line">        launch_ros.actions.Node(</span><br><span class="line">            package&#x3D;&#39;demo_nodes_cpp&#39;, node_executable&#x3D;&#39;talker&#39;, output&#x3D;&#39;screen&#39;,</span><br><span class="line">            node_name&#x3D;[launch.substitutions.LaunchConfiguration(&#39;node_prefix&#39;), &#39;talker&#39;]),</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure>
<p>.launch.py这个后缀其实并没有要求，<code>_lannch.py</code>也是可以的。</p>
<p>launch文件应该定义一个generate_launch_description，并且返回一个LaunchDescription。这样ros2 launch才可以找到</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>虽然可以将启动文件编写为独立的脚本，但ROS中典型的使用方式是由ROS 2工具调用启动文件。</p>
<p>再colcon build之后，应该可以调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ros2 launch my_package script.launch.py</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer>
      
        
        
  
  <div class="tags">
    <a href="/tags/ros2/">ros2</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">Comments</h1>

  
      <div id="fb-root"></div>
<script>
  (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=123456789012345";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

<div class="fb-comments" data-href="https://chargerkong.github.io/2021/04/12/ros2%E5%AD%A6%E4%B9%A0%E4%BA%94/index.html" data-num-posts="5" data-width="840" data-colorscheme="light"></div>
      
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="as_sitesearch" value="chargerkong.github.io">
  </form>
</div>


  

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/gazebo/">gazebo</a><small>1</small></li>
  
    <li><a href="/tags/python/">python</a><small>1</small></li>
  
    <li><a href="/tags/ros2/">ros2</a><small>3</small></li>
  
    <li><a href="/tags/true/">true</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2021 John Doe
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script>
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>


</body>
</html>
